#!/usr/bin/env ruby
# Ruby script to convert PBM file to a C file for use xwith an Atmega CPU
# Requires PRUIM
require 'pruim'

fin   = ARGV[0]
out   = $stdout

# data  = File.read(fin)
image = Pruim::Image.load_from(fin, 'PBM')
raise "Could not read file #{fin}" unless image

puts "// Generated by pbm2c from #{fin}"
# lines = data.split("\n")
# size  = lines[2]
# aid   = size.split(' ')
# wide  = aid[0].to_i
# high  = aid[1].to_i
# p wide, high
# bits  = lines[3..(lines.size)].join('')
# XXX: image height must be multiples of 8
bytes   = image.w * image.h / 8

cname = fin.split('.').first.upcase
puts "#define #{cname}_HIGH #{image.h}"
puts "#define #{cname}_WIDE #{image.w}"
#define O_IMAGE_W 48
nl_after = 6
first    = true
puts "static unsigned char __attribute__ ((progmem)) #{cname}_BMP[] = {"
# Print out all bytes.
# The LCD on the pigeon (like many mono LCD's) represents one column of 
# 8 pixels in the Y direction as a single byte. So we must
# reconstruct that byte, and then print out in y direction first, and then in X
# direction.
xstop    = image.w
ystop    = image.h / 8

for xx in (0...xstop)  
  for yy in (0...ystop)
    aid = 0
    for bit in (0...8)
      pixel = image.getpixel(xx, yy * 8 + 7 - bit)
      next unless pixel
      aid = aid + (1 << bit) # add shifted in bit if the pixel is set
    end
    if first
      first = false
    else
      printf(", ")
    end
    # Print out byte
    byte = aid.to_s(2).rjust(8, '0')
    printf "0b#{byte}"
  end  
  printf "\n"
end

puts "\n};"
  



# (0...bytes).each do |index|
#   printf "\n" if ((index % nl_after) == 0)
#   if first
#     first = false
#   else
#     printf(", ")
#   end
#   start = index * 8
#   part  = bits[start, 8]
#   printf "0b#{part}"
# end
# puts "\n};"
# 






